package cn.ning.pattern.structural.facade;

/*
 * 外观模式。
 *     |--- Facade : 外观角色
 *     |    在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，
 *     |    它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。
 *     |
 *     |--- SubSystem : 子系统角色
 *     |    在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统
 *     |    的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道
 *     |    外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。
 *
 * 定义：
 *     外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个
 *     高层接口，这个接口使得这一子系统更加容易使用。
 *
 * 适用场景：
 *     1. 为复杂的模块或子系统提供外界访问的模块；
 *     2. 子系统相对独立；
 *     3. 预防低水平人员带来的风险。
 *
 * 优点：
 *     1. 减少系统相互依赖；
 *     2. 提高灵活性；
 *     3. 提高了安全性。
 * 缺点：
 *     不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
 */
public class Demo {
    public static void main(String[] args) {
        /* 如果不用外观角色 */
        Person hys = new Person("黄药师"); // 黄药师来了；
        Tea tea = new Tea("铁观音"); // 黄药师想喝铁观音，先买了茶叶；
        Water water = new Water(); // 打来了一桶水；
        Kettle kettle = new Kettle(water); // 将水放入水壶中；
        water.setTea(tea); // 给水中添加茶叶；
        kettle.heating(100); // 煮沸；
        hys.drink(water); //喝茶。

        /* 采用外观模式 */
        Person hqg = new Person("洪七公"); // 洪七公来了。
        TeaHouse teaHouse = new TeaHouse("嘉兴茶楼"); // 洪七公走进嘉兴茶楼
        hqg.drink(teaHouse.makeTea("西湖龙井")); // 洪七公点了一杯西湖龙井，喝茶。

    }
}
